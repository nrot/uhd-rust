/* automatically generated by rust-bindgen 0.63.0 */

pub mod uhd_error {
    #[doc = "! UHD error codes\n*!\n* Each error code corresponds to a specific uhd::exception, with\n* extra codes corresponding to a boost::exception, std::exception,\n* and a catch-all for everything else. When an internal C++ function\n* throws an exception, UHD converts it to one of these error codes\n* to return on the C level.\n*/"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "! No error thrown."]
    pub const UHD_ERROR_NONE: Type = 0;
    #[doc = "! Invalid device arguments."]
    pub const UHD_ERROR_INVALID_DEVICE: Type = 1;
    #[doc = "! See uhd::index_error."]
    pub const UHD_ERROR_INDEX: Type = 10;
    #[doc = "! See uhd::key_error."]
    pub const UHD_ERROR_KEY: Type = 11;
    #[doc = "! See uhd::not_implemented_error."]
    pub const UHD_ERROR_NOT_IMPLEMENTED: Type = 20;
    #[doc = "! See uhd::usb_error."]
    pub const UHD_ERROR_USB: Type = 21;
    #[doc = "! See uhd::io_error."]
    pub const UHD_ERROR_IO: Type = 30;
    #[doc = "! See uhd::os_error."]
    pub const UHD_ERROR_OS: Type = 31;
    #[doc = "! See uhd::assertion_error."]
    pub const UHD_ERROR_ASSERTION: Type = 40;
    #[doc = "! See uhd::lookup_error."]
    pub const UHD_ERROR_LOOKUP: Type = 41;
    #[doc = "! See uhd::type_error."]
    pub const UHD_ERROR_TYPE: Type = 42;
    #[doc = "! See uhd::value_error."]
    pub const UHD_ERROR_VALUE: Type = 43;
    #[doc = "! See uhd::runtime_error."]
    pub const UHD_ERROR_RUNTIME: Type = 44;
    #[doc = "! See uhd::environment_error."]
    pub const UHD_ERROR_ENVIRONMENT: Type = 45;
    #[doc = "! See uhd::system_error."]
    pub const UHD_ERROR_SYSTEM: Type = 46;
    #[doc = "! See uhd::exception."]
    pub const UHD_ERROR_EXCEPT: Type = 47;
    #[doc = "! A boost::exception was thrown."]
    pub const UHD_ERROR_BOOSTEXCEPT: Type = 60;
    #[doc = "! A std::exception was thrown."]
    pub const UHD_ERROR_STDEXCEPT: Type = 70;
    #[doc = "! An unknown error was thrown."]
    pub const UHD_ERROR_UNKNOWN: Type = 100;
}
extern "C" {
    #[doc = "! Return the last error string reported by UHD\n*!\n* Functions that do not take in UHD structs/handles will place any error\n* strings into a buffer that can be queried with this function. Functions that\n* do take in UHD structs/handles will place their error strings in both locations.\n*/"]
    pub fn uhd_get_last_error(
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the ABI compatibility string for this build of the library"]
    pub fn uhd_get_abi_string(
        abi_string_out: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the version string (dotted version number + build info)"]
    pub fn uhd_get_version_string(
        version_out: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> uhd_error::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_rx_metadata_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_tx_metadata_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_async_metadata_t {
    _unused: [u8; 0],
}
#[doc = "! RX metadata interface for describing sent IF data.\n*!\n* See uhd::rx_metadata_t for details.\n*\n* NOTE: Using this handle before calling uhd_rx_metadata_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_rx_metadata_handle = *mut uhd_rx_metadata_t;
#[doc = "! TX metadata interface for describing received IF data.\n*!\n* See uhd::tx_metadata_t for details.\n*\n* NOTE: Using this handle before calling uhd_tx_metadata_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_tx_metadata_handle = *mut uhd_tx_metadata_t;
#[doc = "! Interface for describing transmit-related events.\n*!\n* See uhd::async_metadata_t for details.\n*\n* NOTE: Using this handle before calling uhd_async_metadata_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_async_metadata_handle = *mut uhd_async_metadata_t;
pub mod uhd_rx_metadata_error_code_t {
    #[doc = "! Error condition on a receive call\n*!\n* See uhd::rx_metadata_t::error_code_t for more details.\n*/"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "! No error code associated with this metadata"]
    pub const UHD_RX_METADATA_ERROR_CODE_NONE: Type = 0;
    #[doc = "! No packet received, implementation timed out"]
    pub const UHD_RX_METADATA_ERROR_CODE_TIMEOUT: Type = 1;
    #[doc = "! A stream command was issued in the past"]
    pub const UHD_RX_METADATA_ERROR_CODE_LATE_COMMAND: Type = 2;
    #[doc = "! Expected another stream command"]
    pub const UHD_RX_METADATA_ERROR_CODE_BROKEN_CHAIN: Type = 4;
    #[doc = "! Overflow or sequence error"]
    pub const UHD_RX_METADATA_ERROR_CODE_OVERFLOW: Type = 8;
    #[doc = "! Multi-channel alignment failed"]
    pub const UHD_RX_METADATA_ERROR_CODE_ALIGNMENT: Type = 12;
    #[doc = "! The packet could not be parsed"]
    pub const UHD_RX_METADATA_ERROR_CODE_BAD_PACKET: Type = 15;
}
extern "C" {
    #[doc = "! Create a new RX metadata handle"]
    pub fn uhd_rx_metadata_make(handle: *mut uhd_rx_metadata_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Free an RX metadata handle\n*!\n* Using a handle after freeing it here will result in a segmentation fault.\n*/"]
    pub fn uhd_rx_metadata_free(handle: *mut uhd_rx_metadata_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Has time specification?"]
    pub fn uhd_rx_metadata_has_time_spec(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Time of first sample"]
    pub fn uhd_rx_metadata_time_spec(
        h: uhd_rx_metadata_handle,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Fragmentation flag"]
    pub fn uhd_rx_metadata_more_fragments(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Fragmentation offset"]
    pub fn uhd_rx_metadata_fragment_offset(
        h: uhd_rx_metadata_handle,
        fragment_offset_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Start of burst?"]
    pub fn uhd_rx_metadata_start_of_burst(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! End of burst?"]
    pub fn uhd_rx_metadata_end_of_burst(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Result out of sequence?"]
    pub fn uhd_rx_metadata_out_of_sequence(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Return a pretty-print representation of this metadata.\n*!\n* NOTE: This function will overwrite any string in the given buffer\n* before inserting the pp_string.\n*\n* \\param h metadata handle\n* \\param pp_string_out string buffer for pp_string\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_rx_metadata_to_pp_string(
        h: uhd_rx_metadata_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error state of the RX metadata object."]
    pub fn uhd_rx_metadata_error_code(
        h: uhd_rx_metadata_handle,
        error_code_out: *mut uhd_rx_metadata_error_code_t::Type,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a string representation of the last error state of the RX metadata object.\n*!\n* NOTES:\n* <ul>\n* <li>This is different from the error that can be retrieved with\n*     uhd_rx_metadata_last_error. See uhd::rx_metadata_t::strerror() for details.</li>\n* <li>This function will overwrite any string in the given buffer before\n*     inserting the error string.</li>\n* </ul>\n*\n* \\param h metadata handle\n* \\param strerror_out string buffer for strerror\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_rx_metadata_strerror(
        h: uhd_rx_metadata_handle,
        strerror_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error logged by the RX metadata object.\n*!\n* NOTES:\n* <ul>\n* <li>This is different from the error that can be retrieved with\n*     uhd_rx_metadata_strerror(). See <uhd/error.h> for details.</li>\n* <li>This function will overwrite any string in the given buffer before\n*     inserting the error string.</li>\n* </ul>\n*\n* \\param h metadata handle\n* \\param error_out string buffer for error\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_rx_metadata_last_error(
        h: uhd_rx_metadata_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Create a new TX metadata handle"]
    pub fn uhd_tx_metadata_make(
        handle: *mut uhd_tx_metadata_handle,
        has_time_spec: bool,
        full_secs: i64,
        frac_secs: f64,
        start_of_burst: bool,
        end_of_burst: bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Free an TX metadata handle\n*!\n* Using a handle after freeing it here will result in a segmentation fault.\n*/"]
    pub fn uhd_tx_metadata_free(handle: *mut uhd_tx_metadata_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Has time specification?"]
    pub fn uhd_tx_metadata_has_time_spec(
        h: uhd_tx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get time specification"]
    pub fn uhd_tx_metadata_time_spec(
        h: uhd_tx_metadata_handle,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Start of burst?"]
    pub fn uhd_tx_metadata_start_of_burst(
        h: uhd_tx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! End of burst?"]
    pub fn uhd_tx_metadata_end_of_burst(
        h: uhd_tx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error logged by the TX metadata object.\n*!\n* NOTE: This function will overwrite any string in the given buffer before\n* inserting the error string.\n*\n* \\param h metadata handle\n* \\param error_out string buffer for error\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_tx_metadata_last_error(
        h: uhd_tx_metadata_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
pub mod uhd_async_metadata_event_code_t {
    #[doc = "! The type of event for a receive async message call.\n*!\n* See uhd::async_metadata_t::event_code_t for more details.\n*/"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "! A burst was successfully transmitted."]
    pub const UHD_ASYNC_METADATA_EVENT_CODE_BURST_ACK: Type = 1;
    #[doc = "! An internal send buffer has emptied."]
    pub const UHD_ASYNC_METADATA_EVENT_CODE_UNDERFLOW: Type = 2;
    #[doc = "! Packet loss error between host and device."]
    pub const UHD_ASYNC_METADATA_EVENT_CODE_SEQ_ERROR: Type = 4;
    #[doc = "! Packet had time that was late."]
    pub const UHD_ASYNC_METADATA_EVENT_CODE_TIME_ERROR: Type = 8;
    #[doc = "! Underflow occurred inside a packet."]
    pub const UHD_ASYNC_METADATA_EVENT_CODE_UNDERFLOW_IN_PACKET: Type = 16;
    #[doc = "! Packet loss within a burst."]
    pub const UHD_ASYNC_METADATA_EVENT_CODE_SEQ_ERROR_IN_BURST: Type = 32;
    #[doc = "! Some kind of custom user payload."]
    pub const UHD_ASYNC_METADATA_EVENT_CODE_USER_PAYLOAD: Type = 64;
}
extern "C" {
    #[doc = "! Create a new async metadata handle"]
    pub fn uhd_async_metadata_make(handle: *mut uhd_async_metadata_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Free an async metadata handle\n*!\n* Using a handle after freeing it will result in a segmentation fault.\n*/"]
    pub fn uhd_async_metadata_free(handle: *mut uhd_async_metadata_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Channel number in a MIMO configuration"]
    pub fn uhd_async_metadata_channel(
        h: uhd_async_metadata_handle,
        channel_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Has time specification?"]
    pub fn uhd_async_metadata_has_time_spec(
        h: uhd_async_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get time specification"]
    pub fn uhd_async_metadata_time_spec(
        h: uhd_async_metadata_handle,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get last event code"]
    pub fn uhd_async_metadata_event_code(
        h: uhd_async_metadata_handle,
        event_code_out: *mut uhd_async_metadata_event_code_t::Type,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get payload from custom FPGA fabric"]
    pub fn uhd_async_metadata_user_payload(
        h: uhd_async_metadata_handle,
        user_payload_out: *mut u32,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error logged by the async metadata object.\n*!\n* NOTE: This function will overwrite any string in the given buffer before\n* inserting the error string.\n*\n* \\param h metadata handle\n* \\param error_out string buffer for error\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_async_metadata_last_error(
        h: uhd_async_metadata_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
#[doc = "! Range of floating-point values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_range_t {
    #[doc = "! First value"]
    pub start: f64,
    #[doc = "! Last value"]
    pub stop: f64,
    #[doc = "! Granularity"]
    pub step: f64,
}
#[test]
fn bindgen_test_layout_uhd_range_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_range_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_range_t>(),
        24usize,
        concat!("Size of: ", stringify!(uhd_range_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_range_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_range_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_range_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_range_t),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_range_t),
            "::",
            stringify!(step)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_meta_range_t {
    _unused: [u8; 0],
}
#[doc = "! C-level interface for dealing with a list of ranges\n*!\n* See uhd::meta_range_t for more details.\n*/"]
pub type uhd_meta_range_handle = *mut uhd_meta_range_t;
extern "C" {
    #[doc = "! Get a string representation of the given range"]
    pub fn uhd_range_to_pp_string(
        range: *const uhd_range_t,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Create a meta range handle\n*!\n* NOTE: Using a uhd_meta_range_handle before passing it into this function will\n* result in undefined behavior.\n*/"]
    pub fn uhd_meta_range_make(h: *mut uhd_meta_range_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Destroy a meta range handle\n*!\n* NOTE: Using a uhd_meta_range_handle after passing it into this function will\n* result in a segmentation fault.\n*/"]
    pub fn uhd_meta_range_free(h: *mut uhd_meta_range_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the overall start value for the given meta range"]
    pub fn uhd_meta_range_start(h: uhd_meta_range_handle, start_out: *mut f64) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the overall stop value for the given meta range"]
    pub fn uhd_meta_range_stop(h: uhd_meta_range_handle, stop_out: *mut f64) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the overall step value for the given meta range"]
    pub fn uhd_meta_range_step(h: uhd_meta_range_handle, step_out: *mut f64) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Clip the given value to a possible value in the given range"]
    pub fn uhd_meta_range_clip(
        h: uhd_meta_range_handle,
        value: f64,
        clip_step: bool,
        result_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the number of ranges in the given meta range"]
    pub fn uhd_meta_range_size(h: uhd_meta_range_handle, size_out: *mut usize) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Add a range to the given meta range"]
    pub fn uhd_meta_range_push_back(
        h: uhd_meta_range_handle,
        range: *const uhd_range_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the range at the given index"]
    pub fn uhd_meta_range_at(
        h: uhd_meta_range_handle,
        num: usize,
        range_out: *mut uhd_range_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a string representation of the given meta range"]
    pub fn uhd_meta_range_to_pp_string(
        h: uhd_meta_range_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error recorded by the underlying meta range"]
    pub fn uhd_meta_range_last_error(
        h: uhd_meta_range_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_sensor_value_t {
    _unused: [u8; 0],
}
#[doc = "! C-level interface for a UHD sensor\n*!\n* See uhd::sensor_value_t for more details.\n*\n* NOTE: Using a handle before calling a make function will result in undefined behavior.\n*/"]
pub type uhd_sensor_value_handle = *mut uhd_sensor_value_t;
pub mod uhd_sensor_value_data_type_t {
    #[doc = "! Sensor value types"]
    pub type Type = ::std::os::raw::c_uint;
    pub const UHD_SENSOR_VALUE_BOOLEAN: Type = 98;
    pub const UHD_SENSOR_VALUE_INTEGER: Type = 105;
    pub const UHD_SENSOR_VALUE_REALNUM: Type = 114;
    pub const UHD_SENSOR_VALUE_STRING: Type = 115;
}
extern "C" {
    #[doc = "! Make an empty UHD sensor value.\n*!\n* The purpose of this call is to populate the handle with a valid sensor value\n* object. Querying this object will always yield 'false'. Typically, this\n* sensor value object will never be used, but it will allow the handle object\n* to be used with sensor functions later on.\n*\n* \\param h the sensor handle in which to place sensor\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make(h: *mut uhd_sensor_value_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Make a UHD sensor from a boolean.\n*!\n* \\param h the sensor handle in which to place sensor\n* \\param name sensor name\n* \\param value sensor value\n* \\param utrue string representing \"true\"\n* \\param ufalse string representing \"false\"\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make_from_bool(
        h: *mut uhd_sensor_value_handle,
        name: *const ::std::os::raw::c_char,
        value: bool,
        utrue: *const ::std::os::raw::c_char,
        ufalse: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Make a UHD sensor from an integer.\n*!\n* \\param h the sensor value in which to place sensor\n* \\param name sensor name\n* \\param value sensor value\n* \\param unit sensor unit\n* \\param formatter printf-style format string for value string\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make_from_int(
        h: *mut uhd_sensor_value_handle,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
        unit: *const ::std::os::raw::c_char,
        formatter: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Make a UHD sensor from a real number.\n*!\n* \\param h the sensor value in which to place sensor\n* \\param name sensor name\n* \\param value sensor value\n* \\param unit sensor unit\n* \\param formatter printf-style format string for value string\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make_from_realnum(
        h: *mut uhd_sensor_value_handle,
        name: *const ::std::os::raw::c_char,
        value: f64,
        unit: *const ::std::os::raw::c_char,
        formatter: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Make a UHD sensor from a string.\n*!\n* \\param h the sensor value in which to place sensor\n* \\param name sensor name\n* \\param value sensor value\n* \\param unit sensor unit\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make_from_string(
        h: *mut uhd_sensor_value_handle,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Free the given sensor handle.\n*!\n* Attempting to use the handle after calling this handle will\n* result in a segmentation fault.\n*/"]
    pub fn uhd_sensor_value_free(h: *mut uhd_sensor_value_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the sensor's value as a boolean."]
    pub fn uhd_sensor_value_to_bool(
        h: uhd_sensor_value_handle,
        value_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the sensor's value as an integer."]
    pub fn uhd_sensor_value_to_int(
        h: uhd_sensor_value_handle,
        value_out: *mut ::std::os::raw::c_int,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the sensor's value as a real number."]
    pub fn uhd_sensor_value_to_realnum(
        h: uhd_sensor_value_handle,
        value_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the sensor's name.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the sensor name.\n*\n* \\param h sensor handle\n* \\param name_out string buffer in which to place name\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_name(
        h: uhd_sensor_value_handle,
        name_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the sensor's value.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the sensor value.\n*\n* \\param h sensor handle\n* \\param value_out string buffer in which to place value\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_value(
        h: uhd_sensor_value_handle,
        value_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the sensor's unit.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the sensor unit.\n*\n* \\param h sensor handle\n* \\param unit_out string buffer in which to place unit\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_unit(
        h: uhd_sensor_value_handle,
        unit_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    pub fn uhd_sensor_value_data_type(
        h: uhd_sensor_value_handle,
        data_type_out: *mut uhd_sensor_value_data_type_t::Type,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a pretty-print representation of the given sensor.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the string.\n*\n* \\param h sensor handle\n* \\param pp_string_out string buffer in which to place pp_string\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_to_pp_string(
        h: uhd_sensor_value_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error logged by the sensor handle.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the error string.\n*\n* \\param h sensor handle\n* \\param error_out string buffer in which to place error\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_last_error(
        h: uhd_sensor_value_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
#[doc = "! C-level read-only interface for interacting with a string vector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_string_vector_t {
    _unused: [u8; 0],
}
pub type uhd_string_vector_handle = *mut uhd_string_vector_t;
extern "C" {
    #[doc = "! Instantiate a string_vector handle."]
    pub fn uhd_string_vector_make(h: *mut uhd_string_vector_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Safely destroy a string_vector handle."]
    pub fn uhd_string_vector_free(h: *mut uhd_string_vector_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Add a string to the list"]
    pub fn uhd_string_vector_push_back(
        h: *mut uhd_string_vector_handle,
        value: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the string at the given index"]
    pub fn uhd_string_vector_at(
        h: uhd_string_vector_handle,
        index: usize,
        value_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the number of strings in this list"]
    pub fn uhd_string_vector_size(
        h: uhd_string_vector_handle,
        size_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error reported by the underlying object"]
    pub fn uhd_string_vector_last_error(
        h: uhd_string_vector_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
pub mod uhd_tune_request_policy_t {
    #[doc = "! Policy options for tunable elements in the RF chain."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "! Do not set this argument, use current setting."]
    pub const UHD_TUNE_REQUEST_POLICY_NONE: Type = 78;
    #[doc = "! Automatically determine the argument's value."]
    pub const UHD_TUNE_REQUEST_POLICY_AUTO: Type = 65;
    #[doc = "! Use the argument's value for the setting."]
    pub const UHD_TUNE_REQUEST_POLICY_MANUAL: Type = 77;
}
#[doc = "! Instructs implementation how to tune the RF chain\n*!\n* See uhd::tune_request_t for more details.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_tune_request_t {
    #[doc = "! Target frequency for RF chain in Hz"]
    pub target_freq: f64,
    #[doc = "! RF frequency policy"]
    pub rf_freq_policy: uhd_tune_request_policy_t::Type,
    #[doc = "! RF frequency in Hz"]
    pub rf_freq: f64,
    #[doc = "! DSP frequency policy"]
    pub dsp_freq_policy: uhd_tune_request_policy_t::Type,
    #[doc = "! DSP frequency in Hz"]
    pub dsp_freq: f64,
    #[doc = "! Key-value pairs delimited by commas"]
    pub args: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uhd_tune_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_tune_request_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_tune_request_t>(),
        48usize,
        concat!("Size of: ", stringify!(uhd_tune_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_tune_request_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_tune_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(target_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rf_freq_policy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(rf_freq_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rf_freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(rf_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp_freq_policy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(dsp_freq_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp_freq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(dsp_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(args)
        )
    );
}
#[doc = "! Stores RF and DSP tuned frequencies.\n*!\n* See uhd::tune_result_t for more details.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_tune_result_t {
    #[doc = "! Target RF frequency, clipped to be within system range"]
    pub clipped_rf_freq: f64,
    #[doc = "! Target RF frequency, including RF FE offset"]
    pub target_rf_freq: f64,
    #[doc = "! Frequency to which RF LO is actually tuned"]
    pub actual_rf_freq: f64,
    #[doc = "! Frequency the CORDIC must adjust the RF"]
    pub target_dsp_freq: f64,
    #[doc = "! Frequency to which the CORDIC in the DSP actually tuned"]
    pub actual_dsp_freq: f64,
}
#[test]
fn bindgen_test_layout_uhd_tune_result_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_tune_result_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_tune_result_t>(),
        40usize,
        concat!("Size of: ", stringify!(uhd_tune_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_tune_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_tune_result_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clipped_rf_freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(clipped_rf_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_rf_freq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(target_rf_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual_rf_freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(actual_rf_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_dsp_freq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(target_dsp_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual_dsp_freq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(actual_dsp_freq)
        )
    );
}
extern "C" {
    #[doc = "! Create a pretty print representation of this tune result."]
    pub fn uhd_tune_result_to_pp_string(
        tune_result: *mut uhd_tune_result_t,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    );
}
#[doc = "! USRP RX info\n*!\n* This struct is populated by uhd_usrp_get_rx_info().\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_usrp_rx_info_t {
    #[doc = "! Motherboard ID"]
    pub mboard_id: *mut ::std::os::raw::c_char,
    #[doc = "! Motherboard name"]
    pub mboard_name: *mut ::std::os::raw::c_char,
    #[doc = "! Motherboard serial"]
    pub mboard_serial: *mut ::std::os::raw::c_char,
    #[doc = "! RX daughterboard ID"]
    pub rx_id: *mut ::std::os::raw::c_char,
    #[doc = "! RX subdev name"]
    pub rx_subdev_name: *mut ::std::os::raw::c_char,
    #[doc = "! RX subdev spec"]
    pub rx_subdev_spec: *mut ::std::os::raw::c_char,
    #[doc = "! RX daughterboard serial"]
    pub rx_serial: *mut ::std::os::raw::c_char,
    #[doc = "! RX daughterboard antenna"]
    pub rx_antenna: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uhd_usrp_rx_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_usrp_rx_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_usrp_rx_info_t>(),
        64usize,
        concat!("Size of: ", stringify!(uhd_usrp_rx_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_usrp_rx_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_usrp_rx_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(mboard_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(mboard_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_serial) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(mboard_serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_subdev_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_subdev_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_subdev_spec) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_subdev_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_serial) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_antenna) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_antenna)
        )
    );
}
#[doc = "! USRP TX info\n*!\n* This struct is populated by uhd_usrp_get_tx_info().\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_usrp_tx_info_t {
    #[doc = "! Motherboard ID"]
    pub mboard_id: *mut ::std::os::raw::c_char,
    #[doc = "! Motherboard name"]
    pub mboard_name: *mut ::std::os::raw::c_char,
    #[doc = "! Motherboard serial"]
    pub mboard_serial: *mut ::std::os::raw::c_char,
    #[doc = "! TX daughterboard ID"]
    pub tx_id: *mut ::std::os::raw::c_char,
    #[doc = "! TX subdev name"]
    pub tx_subdev_name: *mut ::std::os::raw::c_char,
    #[doc = "! TX subdev spec"]
    pub tx_subdev_spec: *mut ::std::os::raw::c_char,
    #[doc = "! TX daughterboard serial"]
    pub tx_serial: *mut ::std::os::raw::c_char,
    #[doc = "! TX daughterboard antenna"]
    pub tx_antenna: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uhd_usrp_tx_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_usrp_tx_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_usrp_tx_info_t>(),
        64usize,
        concat!("Size of: ", stringify!(uhd_usrp_tx_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_usrp_tx_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_usrp_tx_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(mboard_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(mboard_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_serial) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(mboard_serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_subdev_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_subdev_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_subdev_spec) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_subdev_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_serial) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_antenna) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_antenna)
        )
    );
}
extern "C" {
    #[doc = "! Clean up a uhd_usrp_rx_info_t populated by uhd_usrp_get_rx_info().\n*!\n* NOTE: If this function is passed a uhd_usrp_rx_info_t that has not\n* been populated by uhd_usrp_get_rx_info(), it will produce a double-free\n* error.\n*/"]
    pub fn uhd_usrp_rx_info_free(rx_info: *mut uhd_usrp_rx_info_t) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Clean up a uhd_usrp_tx_info_t populated by uhd_usrp_get_tx_info().\n*!\n* NOTE: If this function is passed a uhd_usrp_tx_info_t that has not\n* been populated by uhd_usrp_get_tx_info(), it will produce a double-free\n* error.\n*/"]
    pub fn uhd_usrp_tx_info_free(tx_info: *mut uhd_usrp_tx_info_t) -> uhd_error::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_dboard_eeprom_t {
    _unused: [u8; 0],
}
#[doc = "! A C-level interface for interacting with a daughterboard EEPROM\n*!\n* See uhd::usrp::dboard_eeprom_t for more details.\n*\n* NOTE: Using a handle before passing it into uhd_dboard_eeprom_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_dboard_eeprom_handle = *mut uhd_dboard_eeprom_t;
extern "C" {
    #[doc = "! Create handle for a USRP daughterboard EEPROM"]
    pub fn uhd_dboard_eeprom_make(h: *mut uhd_dboard_eeprom_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Safely destroy the given handle\n*!\n* NOTE: Using a handle after passing it into this function will result in\n* a segmentation fault.\n*/"]
    pub fn uhd_dboard_eeprom_free(h: *mut uhd_dboard_eeprom_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the ID associated with the given daughterboard as a string hex representation"]
    pub fn uhd_dboard_eeprom_get_id(
        h: uhd_dboard_eeprom_handle,
        id_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the daughterboard ID using a string hex representation"]
    pub fn uhd_dboard_eeprom_set_id(
        h: uhd_dboard_eeprom_handle,
        id: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the daughterboard's serial"]
    pub fn uhd_dboard_eeprom_get_serial(
        h: uhd_dboard_eeprom_handle,
        serial_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the daughterboard's serial"]
    pub fn uhd_dboard_eeprom_set_serial(
        h: uhd_dboard_eeprom_handle,
        serial: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = " Get the daughterboard's revision\n\n The revision doesn't always have to be present, in which case this function\n will return an error."]
    pub fn uhd_dboard_eeprom_get_revision(
        h: uhd_dboard_eeprom_handle,
        revision_out: *mut ::std::os::raw::c_int,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the daughterboard's revision"]
    pub fn uhd_dboard_eeprom_set_revision(
        h: uhd_dboard_eeprom_handle,
        revision: ::std::os::raw::c_int,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error reported by the handle"]
    pub fn uhd_dboard_eeprom_last_error(
        h: uhd_dboard_eeprom_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_mboard_eeprom_t {
    _unused: [u8; 0],
}
#[doc = "! A C-level interface for interacting with a USRP motherboard's EEPROM\n*!\n* See uhd::usrp::mboard_eeprom_t for more details.\n*\n* NOTE: Using a handle before passing it into uhd_mboard_eeprom_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_mboard_eeprom_handle = *mut uhd_mboard_eeprom_t;
extern "C" {
    #[doc = "! Create a handle for working with a USRP motherboard EEPROM"]
    pub fn uhd_mboard_eeprom_make(h: *mut uhd_mboard_eeprom_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Free a USRP motherboard EEPROM handle\n*!\n* NOTE: Using a handle after passing it into this function will result in\n* a segmentation fault.\n*/"]
    pub fn uhd_mboard_eeprom_free(h: *mut uhd_mboard_eeprom_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the value associated with the given EEPROM key"]
    pub fn uhd_mboard_eeprom_get_value(
        h: uhd_mboard_eeprom_handle,
        key: *const ::std::os::raw::c_char,
        value_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the value for the given EEPROM key"]
    pub fn uhd_mboard_eeprom_set_value(
        h: uhd_mboard_eeprom_handle,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error recorded by the handle"]
    pub fn uhd_mboard_eeprom_last_error(
        h: uhd_mboard_eeprom_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
#[doc = "! Subdevice specification"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_subdev_spec_pair_t {
    pub db_name: *mut ::std::os::raw::c_char,
    #[doc = "! Subdevice name"]
    pub sd_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uhd_subdev_spec_pair_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_subdev_spec_pair_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_subdev_spec_pair_t>(),
        16usize,
        concat!("Size of: ", stringify!(uhd_subdev_spec_pair_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_subdev_spec_pair_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_subdev_spec_pair_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_subdev_spec_pair_t),
            "::",
            stringify!(db_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sd_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_subdev_spec_pair_t),
            "::",
            stringify!(sd_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_subdev_spec_t {
    _unused: [u8; 0],
}
#[doc = "! A C-level interface for working with a list of subdevice specifications\n*!\n* See uhd::usrp::subdev_spec_t for more details.\n*\n* NOTE: Using a handle before passing it into uhd_subdev_spec_make() will result in\n* undefined behavior.\n*/"]
pub type uhd_subdev_spec_handle = *mut uhd_subdev_spec_t;
extern "C" {
    #[doc = "! Safely destroy any memory created in the generation of a uhd_subdev_spec_pair_t"]
    pub fn uhd_subdev_spec_pair_free(
        subdev_spec_pair: *mut uhd_subdev_spec_pair_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Check to see if two subdevice specifications are equal"]
    pub fn uhd_subdev_spec_pairs_equal(
        first: *const uhd_subdev_spec_pair_t,
        second: *const uhd_subdev_spec_pair_t,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Create a handle for a list of subdevice specifications"]
    pub fn uhd_subdev_spec_make(
        h: *mut uhd_subdev_spec_handle,
        markup: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Safely destroy a subdevice specification handle\n*!\n* NOTE: Using a handle after passing it into this function will result in\n* a segmentation fault.\n*/"]
    pub fn uhd_subdev_spec_free(h: *mut uhd_subdev_spec_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Check how many subdevice specifications are in this list"]
    pub fn uhd_subdev_spec_size(h: uhd_subdev_spec_handle, size_out: *mut usize)
        -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Add a subdevice specification to this list"]
    pub fn uhd_subdev_spec_push_back(
        h: uhd_subdev_spec_handle,
        markup: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the subdevice specification at the given index"]
    pub fn uhd_subdev_spec_at(
        h: uhd_subdev_spec_handle,
        num: usize,
        subdev_spec_pair_out: *mut uhd_subdev_spec_pair_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a string representation of the given list"]
    pub fn uhd_subdev_spec_to_pp_string(
        h: uhd_subdev_spec_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a markup string representation of the given list"]
    pub fn uhd_subdev_spec_to_string(
        h: uhd_subdev_spec_handle,
        string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error recorded by the given handle"]
    pub fn uhd_subdev_spec_last_error(
        h: uhd_subdev_spec_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
#[doc = "! A struct of parameters to construct a stream.\n*!\n* See uhd::stream_args_t for more details.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_stream_args_t {
    #[doc = "! Format of host memory"]
    pub cpu_format: *mut ::std::os::raw::c_char,
    #[doc = "! Over-the-wire format"]
    pub otw_format: *mut ::std::os::raw::c_char,
    #[doc = "! Other stream args"]
    pub args: *mut ::std::os::raw::c_char,
    #[doc = "! Array that lists channels"]
    pub channel_list: *mut usize,
    #[doc = "! Number of channels"]
    pub n_channels: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uhd_stream_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_stream_args_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_stream_args_t>(),
        40usize,
        concat!("Size of: ", stringify!(uhd_stream_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_stream_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_stream_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(cpu_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).otw_format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(otw_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(channel_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_channels) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(n_channels)
        )
    );
}
pub mod uhd_stream_mode_t {
    #[doc = "! How streaming is issued to the device\n*!\n* See uhd::stream_cmd_t for more details.\n*/"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "! Stream samples indefinitely"]
    pub const UHD_STREAM_MODE_START_CONTINUOUS: Type = 97;
    #[doc = "! End continuous streaming"]
    pub const UHD_STREAM_MODE_STOP_CONTINUOUS: Type = 111;
    #[doc = "! Stream some number of samples and finish"]
    pub const UHD_STREAM_MODE_NUM_SAMPS_AND_DONE: Type = 100;
    #[doc = "! Stream some number of samples but expect more"]
    pub const UHD_STREAM_MODE_NUM_SAMPS_AND_MORE: Type = 109;
}
#[doc = "! Define how device streams to host\n*!\n* See uhd::stream_cmd_t for more details.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_stream_cmd_t {
    #[doc = "! How streaming is issued to the device"]
    pub stream_mode: uhd_stream_mode_t::Type,
    #[doc = "! Number of samples"]
    pub num_samps: usize,
    #[doc = "! Stream now?"]
    pub stream_now: bool,
    #[doc = "! If not now, then full seconds into future to stream"]
    pub time_spec_full_secs: i64,
    #[doc = "! If not now, then fractional seconds into future to stream"]
    pub time_spec_frac_secs: f64,
}
#[test]
fn bindgen_test_layout_uhd_stream_cmd_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_stream_cmd_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_stream_cmd_t>(),
        40usize,
        concat!("Size of: ", stringify!(uhd_stream_cmd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_stream_cmd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_stream_cmd_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(stream_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_samps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(num_samps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_now) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(stream_now)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_spec_full_secs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(time_spec_full_secs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_spec_frac_secs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(time_spec_frac_secs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_rx_streamer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_tx_streamer {
    _unused: [u8; 0],
}
#[doc = "! C-level interface for working with an RX streamer\n*!\n* See uhd::rx_streamer for more details.\n*/"]
pub type uhd_rx_streamer_handle = *mut uhd_rx_streamer;
#[doc = "! C-level interface for working with a TX streamer\n*!\n* See uhd::tx_streamer for more details.\n*/"]
pub type uhd_tx_streamer_handle = *mut uhd_tx_streamer;
extern "C" {
    #[doc = "! Create an RX streamer handle.\n*!\n* NOTE: Using this streamer before passing it into uhd_usrp_get_rx_stream()\n* will result in undefined behavior.\n*/"]
    pub fn uhd_rx_streamer_make(h: *mut uhd_rx_streamer_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Free an RX streamer handle.\n*!\n* NOTE: Using a streamer after passing it into this function will result\n* in a segmentation fault.\n*/"]
    pub fn uhd_rx_streamer_free(h: *mut uhd_rx_streamer_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the number of channels associated with this streamer"]
    pub fn uhd_rx_streamer_num_channels(
        h: uhd_rx_streamer_handle,
        num_channels_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the max number of samples per buffer per packet"]
    pub fn uhd_rx_streamer_max_num_samps(
        h: uhd_rx_streamer_handle,
        max_num_samps_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Receive buffers containing samples into the given RX streamer\n*!\n* See uhd::rx_streamer::recv() for more details.\n*\n* \\param h RX streamer handle\n* \\param buffs pointer to buffers in which to receive samples\n* \\param samps_per_buff max number of samples per buffer\n* \\param md handle to RX metadata in which to receive results\n* \\param timeout timeout in seconds to wait for a packet\n* \\param one_packet send a single packet\n* \\param items_recvd pointer to output variable for number of samples received\n*/"]
    pub fn uhd_rx_streamer_recv(
        h: uhd_rx_streamer_handle,
        buffs: *mut *mut ::std::os::raw::c_void,
        samps_per_buff: usize,
        md: *mut uhd_rx_metadata_handle,
        timeout: f64,
        one_packet: bool,
        items_recvd: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Issue the given stream command\n*!\n* See uhd::rx_streamer::issue_stream_cmd() for more details.\n*/"]
    pub fn uhd_rx_streamer_issue_stream_cmd(
        h: uhd_rx_streamer_handle,
        stream_cmd: *const uhd_stream_cmd_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error reported by the RX streamer\n*!\n* NOTE: This will overwrite the string currently in error_out before\n* using it to return its error.\n*\n* \\param h RX streamer handle\n* \\param error_out string buffer in which to place error\n* \\param strbuffer_len buffer size\n*/"]
    pub fn uhd_rx_streamer_last_error(
        h: uhd_rx_streamer_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Create an TX streamer handle.\n*!\n* NOTE: Using this streamer before passing it into uhd_usrp_get_tx_stream()\n* will result in undefined behavior.\n*/"]
    pub fn uhd_tx_streamer_make(h: *mut uhd_tx_streamer_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Free an TX streamer handle.\n*!\n* NOTE: Using a streamer after passing it into this function will result\n* in a segmentation fault.\n*/"]
    pub fn uhd_tx_streamer_free(h: *mut uhd_tx_streamer_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the number of channels associated with this streamer"]
    pub fn uhd_tx_streamer_num_channels(
        h: uhd_tx_streamer_handle,
        num_channels_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the max number of samples per buffer per packet"]
    pub fn uhd_tx_streamer_max_num_samps(
        h: uhd_tx_streamer_handle,
        max_num_samps_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Send buffers containing samples described by the metadata\n*!\n* See uhd::tx_streamer::send() for more details.\n*\n* \\param h TX streamer handle\n* \\param buffs pointer to buffers containing samples to send\n* \\param samps_per_buff max number of samples per buffer\n* \\param md handle to TX metadata\n* \\param timeout timeout in seconds to wait for a packet\n* \\param items_sent pointer to output variable for number of samples send\n*/"]
    pub fn uhd_tx_streamer_send(
        h: uhd_tx_streamer_handle,
        buffs: *mut *const ::std::os::raw::c_void,
        samps_per_buff: usize,
        md: *mut uhd_tx_metadata_handle,
        timeout: f64,
        items_sent: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Receive an asynchronous message from this streamer\n*!\n* See uhd::tx_streamer::recv_async_msg() for more details.\n*/"]
    pub fn uhd_tx_streamer_recv_async_msg(
        h: uhd_tx_streamer_handle,
        md: *mut uhd_async_metadata_handle,
        timeout: f64,
        valid: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error reported by the TX streamer\n*!\n* NOTE: This will overwrite the string currently in error_out before\n* using it to return its error.\n*\n* \\param h TX streamer handle\n* \\param error_out string buffer in which to place error\n* \\param strbuffer_len buffer size\n*/"]
    pub fn uhd_tx_streamer_last_error(
        h: uhd_tx_streamer_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
#[doc = " Public Datatypes for USRP / streamer handling."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_usrp {
    _unused: [u8; 0],
}
#[doc = "! C-level interface for working with a USRP device"]
pub type uhd_usrp_handle = *mut uhd_usrp;
extern "C" {
    #[doc = "! Find all connected USRP devices.\n*!\n* See uhd::device::find() for more details.\n*/"]
    pub fn uhd_usrp_find(
        args: *const ::std::os::raw::c_char,
        strings_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Create a USRP handle.\n*!\n* \\param h the handle\n* \\param args device args (e.g. \"type=x300\")\n*/"]
    pub fn uhd_usrp_make(
        h: *mut uhd_usrp_handle,
        args: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Safely destroy the USRP object underlying the handle.\n*!\n* NOTE: Attempting to use a USRP handle after passing it into this function\n* will result in a segmentation fault.\n*/"]
    pub fn uhd_usrp_free(h: *mut uhd_usrp_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the last error reported by the USRP handle"]
    pub fn uhd_usrp_last_error(
        h: uhd_usrp_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Create RX streamer from a USRP handle and given stream args"]
    pub fn uhd_usrp_get_rx_stream(
        h: uhd_usrp_handle,
        stream_args: *mut uhd_stream_args_t,
        h_out: uhd_rx_streamer_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Create TX streamer from a USRP handle and given stream args"]
    pub fn uhd_usrp_get_tx_stream(
        h: uhd_usrp_handle,
        stream_args: *mut uhd_stream_args_t,
        h_out: uhd_tx_streamer_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get RX info from the USRP device\n*!\n* NOTE: After calling this function, uhd_usrp_rx_info_free() must be called on info_out.\n*/"]
    pub fn uhd_usrp_get_rx_info(
        h: uhd_usrp_handle,
        chan: usize,
        info_out: *mut uhd_usrp_rx_info_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get TX info from the USRP device\n*!\n* NOTE: After calling this function, uhd_usrp_tx_info_free() must be called on info_out.\n*/"]
    pub fn uhd_usrp_get_tx_info(
        h: uhd_usrp_handle,
        chan: usize,
        info_out: *mut uhd_usrp_tx_info_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the master clock rate.\n*!\n* See uhd::usrp::multi_usrp::set_master_clock_rate() for more details.\n*/"]
    pub fn uhd_usrp_set_master_clock_rate(
        h: uhd_usrp_handle,
        rate: f64,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the master clock rate.\n*!\n* See uhd::usrp::multi_usrp::get_master_clock_rate() for more details.\n*/"]
    pub fn uhd_usrp_get_master_clock_rate(
        h: uhd_usrp_handle,
        mboard: usize,
        clock_rate_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a pretty-print representation of the USRP device.\n*!\n* See uhd::usrp::multi_usrp::get_pp_string() for more details.\n*/"]
    pub fn uhd_usrp_get_pp_string(
        h: uhd_usrp_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the motherboard name for the given device\n*!\n* See uhd::usrp::multi_usrp::get_mboard_name() for more details.\n*/"]
    pub fn uhd_usrp_get_mboard_name(
        h: uhd_usrp_handle,
        mboard: usize,
        mboard_name_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the USRP device's current internal time\n*!\n* See uhd::usrp::multi_usrp::get_time_now() for more details.\n*/"]
    pub fn uhd_usrp_get_time_now(
        h: uhd_usrp_handle,
        mboard: usize,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the time when this device's last PPS pulse occurred\n*!\n* See uhd::usrp::multi_usrp::get_time_last_pps() for more details.\n*/"]
    pub fn uhd_usrp_get_time_last_pps(
        h: uhd_usrp_handle,
        mboard: usize,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the USRP device's time\n*!\n* See uhd::usrp::multi_usrp::set_time_now() for more details.\n*/"]
    pub fn uhd_usrp_set_time_now(
        h: uhd_usrp_handle,
        full_secs: i64,
        frac_secs: f64,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the USRP device's time to the given value upon the next PPS detection\n*!\n* See uhd::usrp::multi_usrp::set_time_next_pps() for more details.\n*/"]
    pub fn uhd_usrp_set_time_next_pps(
        h: uhd_usrp_handle,
        full_secs: i64,
        frac_secs: f64,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Synchronize the time across all motherboards\n*!\n* See uhd::usrp::multi_usrp::set_time_unknown_pps() for more details.\n*/"]
    pub fn uhd_usrp_set_time_unknown_pps(
        h: uhd_usrp_handle,
        full_secs: i64,
        frac_secs: f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Are all motherboard times synchronized?"]
    pub fn uhd_usrp_get_time_synchronized(
        h: uhd_usrp_handle,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the time at which timed commands will take place\n*!\n* See uhd::usrp::multi_usrp::set_command_time() for more details.\n*/"]
    pub fn uhd_usrp_set_command_time(
        h: uhd_usrp_handle,
        full_secs: i64,
        frac_secs: f64,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Clear the command time so that commands are sent ASAP"]
    pub fn uhd_usrp_clear_command_time(h: uhd_usrp_handle, mboard: usize) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the time source for the given device\n*!\n* See uhd::usrp::multi_usrp::set_time_source() for more details.\n*/"]
    pub fn uhd_usrp_set_time_source(
        h: uhd_usrp_handle,
        time_source: *const ::std::os::raw::c_char,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the time source for the given device\n*!\n* See uhd::usrp::multi_usrp::get_time_source() for more details.\n*/"]
    pub fn uhd_usrp_get_time_source(
        h: uhd_usrp_handle,
        mboard: usize,
        time_source_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of time sources for the given device"]
    pub fn uhd_usrp_get_time_sources(
        h: uhd_usrp_handle,
        mboard: usize,
        time_sources_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the given device's clock source\n*!\n* See uhd::usrp::multi_usrp::set_clock_source() for more details.\n*/"]
    pub fn uhd_usrp_set_clock_source(
        h: uhd_usrp_handle,
        clock_source: *const ::std::os::raw::c_char,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the given device's clock source\n*!\n* See uhd::usrp::multi_usrp::get_clock_source() for more details.\n*/"]
    pub fn uhd_usrp_get_clock_source(
        h: uhd_usrp_handle,
        mboard: usize,
        clock_source_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of clock sources for the given device"]
    pub fn uhd_usrp_get_clock_sources(
        h: uhd_usrp_handle,
        mboard: usize,
        clock_sources_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Enable or disable sending the clock source to an output connector\n*!\n* See uhd::usrp::set_clock_source_out() for more details.\n*/"]
    pub fn uhd_usrp_set_clock_source_out(
        h: uhd_usrp_handle,
        enb: bool,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Enable or disable sending the time source to an output connector\n*!\n* See uhd::usrp::set_time_source_out() for more details.\n*/"]
    pub fn uhd_usrp_set_time_source_out(
        h: uhd_usrp_handle,
        enb: bool,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the number of devices associated with the given USRP handle"]
    pub fn uhd_usrp_get_num_mboards(
        h: uhd_usrp_handle,
        num_mboards_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the value associated with the given sensor name"]
    pub fn uhd_usrp_get_mboard_sensor(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        mboard: usize,
        sensor_value_out: *mut uhd_sensor_value_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of motherboard sensors for the given device"]
    pub fn uhd_usrp_get_mboard_sensor_names(
        h: uhd_usrp_handle,
        mboard: usize,
        mboard_sensor_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Perform a write on a user configuration register bus\n*!\n* See uhd::usrp::multi_usrp::set_user_register() for more details.\n*/"]
    pub fn uhd_usrp_set_user_register(
        h: uhd_usrp_handle,
        addr: u8,
        data: u32,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a handle for the given motherboard's EEPROM"]
    pub fn uhd_usrp_get_mboard_eeprom(
        h: uhd_usrp_handle,
        mb_eeprom: uhd_mboard_eeprom_handle,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set values in the given motherboard's EEPROM"]
    pub fn uhd_usrp_set_mboard_eeprom(
        h: uhd_usrp_handle,
        mb_eeprom: uhd_mboard_eeprom_handle,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a handle for the given device's daughterboard EEPROM"]
    pub fn uhd_usrp_get_dboard_eeprom(
        h: uhd_usrp_handle,
        db_eeprom: uhd_dboard_eeprom_handle,
        unit: *const ::std::os::raw::c_char,
        slot: *const ::std::os::raw::c_char,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set values in the given daughterboard's EEPROM"]
    pub fn uhd_usrp_set_dboard_eeprom(
        h: uhd_usrp_handle,
        db_eeprom: uhd_dboard_eeprom_handle,
        unit: *const ::std::os::raw::c_char,
        slot: *const ::std::os::raw::c_char,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Map the given device's RX frontend to a channel\n*!\n* See uhd::usrp::multi_usrp::set_rx_subdev_spec() for more details.\n*/"]
    pub fn uhd_usrp_set_rx_subdev_spec(
        h: uhd_usrp_handle,
        subdev_spec: uhd_subdev_spec_handle,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the RX frontend specification for the given device"]
    pub fn uhd_usrp_get_rx_subdev_spec(
        h: uhd_usrp_handle,
        mboard: usize,
        subdev_spec_out: uhd_subdev_spec_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the number of RX channels for the given handle"]
    pub fn uhd_usrp_get_rx_num_channels(
        h: uhd_usrp_handle,
        num_channels_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the name for the RX frontend"]
    pub fn uhd_usrp_get_rx_subdev_name(
        h: uhd_usrp_handle,
        chan: usize,
        rx_subdev_name_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the given RX channel's sample rate (in Sps)"]
    pub fn uhd_usrp_set_rx_rate(h: uhd_usrp_handle, rate: f64, chan: usize) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the given RX channel's sample rate (in Sps)"]
    pub fn uhd_usrp_get_rx_rate(
        h: uhd_usrp_handle,
        chan: usize,
        rate_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a range of possible RX rates for the given channel"]
    pub fn uhd_usrp_get_rx_rates(
        h: uhd_usrp_handle,
        chan: usize,
        rates_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the given channel's center RX frequency"]
    pub fn uhd_usrp_set_rx_freq(
        h: uhd_usrp_handle,
        tune_request: *mut uhd_tune_request_t,
        chan: usize,
        tune_result: *mut uhd_tune_result_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the given channel's center RX frequency"]
    pub fn uhd_usrp_get_rx_freq(
        h: uhd_usrp_handle,
        chan: usize,
        freq_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get all possible center frequency ranges for the given channel\n*!\n* See uhd::usrp::multi_usrp::get_rx_freq_range() for more details.\n*/"]
    pub fn uhd_usrp_get_rx_freq_range(
        h: uhd_usrp_handle,
        chan: usize,
        freq_range_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get all possible RF frequency ranges for the given channel's RX RF frontend"]
    pub fn uhd_usrp_get_fe_rx_freq_range(
        h: uhd_usrp_handle,
        chan: usize,
        freq_range_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of possible LO stage names"]
    pub fn uhd_usrp_get_rx_lo_names(
        h: uhd_usrp_handle,
        chan: usize,
        rx_lo_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the LO source for the USRP device"]
    pub fn uhd_usrp_set_rx_lo_source(
        h: uhd_usrp_handle,
        src: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the currently set LO source"]
    pub fn uhd_usrp_get_rx_lo_source(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        rx_lo_source_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of possible LO sources"]
    pub fn uhd_usrp_get_rx_lo_sources(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        rx_lo_sources_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set whether the LO used by the USRP device is exported"]
    pub fn uhd_usrp_set_rx_lo_export_enabled(
        h: uhd_usrp_handle,
        enabled: bool,
        name: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Returns true if the currently selected LO is being exported."]
    pub fn uhd_usrp_get_rx_lo_export_enabled(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the RX LO frequency."]
    pub fn uhd_usrp_set_rx_lo_freq(
        h: uhd_usrp_handle,
        freq: f64,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        coerced_freq_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the current RX LO frequency."]
    pub fn uhd_usrp_get_rx_lo_freq(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        rx_lo_freq_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the RX gain for the given channel and name"]
    pub fn uhd_usrp_set_rx_gain(
        h: uhd_usrp_handle,
        gain: f64,
        chan: usize,
        gain_name: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the normalized RX gain [0.0, 1.0] for the given channel\n*!\n* See uhd::usrp::multi_usrp::set_normalized_rx_gain() for more details.\n*/"]
    pub fn uhd_usrp_set_normalized_rx_gain(
        h: uhd_usrp_handle,
        gain: f64,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Enable or disable the given channel's RX AGC module\n*!\n* See uhd::usrp::multi_usrp::set_rx_agc() for more details.\n*/"]
    pub fn uhd_usrp_set_rx_agc(h: uhd_usrp_handle, enable: bool, chan: usize) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the given channel's RX gain"]
    pub fn uhd_usrp_get_rx_gain(
        h: uhd_usrp_handle,
        chan: usize,
        gain_name: *const ::std::os::raw::c_char,
        gain_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the given channel's normalized RX gain [0.0, 1.0]\n*!\n* See uhd::usrp::multi_usrp::get_normalized_rx_gain() for more details.\n*/"]
    pub fn uhd_usrp_get_normalized_rx_gain(
        h: uhd_usrp_handle,
        chan: usize,
        gain_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get all possible gain ranges for the given channel and name"]
    pub fn uhd_usrp_get_rx_gain_range(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        gain_range_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of RX gain names for the given channel"]
    pub fn uhd_usrp_get_rx_gain_names(
        h: uhd_usrp_handle,
        chan: usize,
        gain_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the RX antenna for the given channel"]
    pub fn uhd_usrp_set_rx_antenna(
        h: uhd_usrp_handle,
        ant: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the RX antenna for the given channel"]
    pub fn uhd_usrp_get_rx_antenna(
        h: uhd_usrp_handle,
        chan: usize,
        ant_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of RX antennas associated with the given channels"]
    pub fn uhd_usrp_get_rx_antennas(
        h: uhd_usrp_handle,
        chan: usize,
        antennas_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of RX sensors associated with the given channels"]
    pub fn uhd_usrp_get_rx_sensor_names(
        h: uhd_usrp_handle,
        chan: usize,
        sensor_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the bandwidth for the given channel's RX frontend"]
    pub fn uhd_usrp_set_rx_bandwidth(
        h: uhd_usrp_handle,
        bandwidth: f64,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the bandwidth for the given channel's RX frontend"]
    pub fn uhd_usrp_get_rx_bandwidth(
        h: uhd_usrp_handle,
        chan: usize,
        bandwidth_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get all possible bandwidth ranges for the given channel's RX frontend"]
    pub fn uhd_usrp_get_rx_bandwidth_range(
        h: uhd_usrp_handle,
        chan: usize,
        bandwidth_range_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the value for the given RX sensor"]
    pub fn uhd_usrp_get_rx_sensor(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        sensor_value_out: *mut uhd_sensor_value_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Enable or disable RX DC offset correction for the given channel\n*!\n* See uhd::usrp::multi_usrp::set_rx_dc_offset() for more details.\n*/"]
    pub fn uhd_usrp_set_rx_dc_offset_enabled(
        h: uhd_usrp_handle,
        enb: bool,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Enable or disable RX IQ imbalance correction for the given channel"]
    pub fn uhd_usrp_set_rx_iq_balance_enabled(
        h: uhd_usrp_handle,
        enb: bool,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Map the given device's TX frontend to a channel\n*!\n* See uhd::usrp::multi_usrp::set_tx_subdev_spec() for more details.\n*/"]
    pub fn uhd_usrp_set_tx_subdev_spec(
        h: uhd_usrp_handle,
        subdev_spec: uhd_subdev_spec_handle,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the TX frontend specification for the given device"]
    pub fn uhd_usrp_get_tx_subdev_spec(
        h: uhd_usrp_handle,
        mboard: usize,
        subdev_spec_out: uhd_subdev_spec_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the number of TX channels for the given handle"]
    pub fn uhd_usrp_get_tx_num_channels(
        h: uhd_usrp_handle,
        num_channels_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the name for the RX frontend"]
    pub fn uhd_usrp_get_tx_subdev_name(
        h: uhd_usrp_handle,
        chan: usize,
        tx_subdev_name_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the given RX channel's sample rate (in Sps)"]
    pub fn uhd_usrp_set_tx_rate(h: uhd_usrp_handle, rate: f64, chan: usize) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the given RX channel's sample rate (in Sps)"]
    pub fn uhd_usrp_get_tx_rate(
        h: uhd_usrp_handle,
        chan: usize,
        rate_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a range of possible RX rates for the given channel"]
    pub fn uhd_usrp_get_tx_rates(
        h: uhd_usrp_handle,
        chan: usize,
        rates_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the given channel's center TX frequency"]
    pub fn uhd_usrp_set_tx_freq(
        h: uhd_usrp_handle,
        tune_request: *mut uhd_tune_request_t,
        chan: usize,
        tune_result: *mut uhd_tune_result_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the given channel's center TX frequency"]
    pub fn uhd_usrp_get_tx_freq(
        h: uhd_usrp_handle,
        chan: usize,
        freq_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get all possible center frequency ranges for the given channel\n*!\n* See uhd::usrp::multi_usrp::get_rx_freq_range() for more details.\n*/"]
    pub fn uhd_usrp_get_tx_freq_range(
        h: uhd_usrp_handle,
        chan: usize,
        freq_range_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get all possible RF frequency ranges for the given channel's TX RF frontend"]
    pub fn uhd_usrp_get_fe_tx_freq_range(
        h: uhd_usrp_handle,
        chan: usize,
        freq_range_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of possible LO stage names"]
    pub fn uhd_usrp_get_tx_lo_names(
        h: uhd_usrp_handle,
        chan: usize,
        tx_lo_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the LO source for the USRP device"]
    pub fn uhd_usrp_set_tx_lo_source(
        h: uhd_usrp_handle,
        src: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the currently set LO source"]
    pub fn uhd_usrp_get_tx_lo_source(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        tx_lo_source_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of possible LO sources"]
    pub fn uhd_usrp_get_tx_lo_sources(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        tx_lo_sources_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set whether the LO used by the USRP device is exported"]
    pub fn uhd_usrp_set_tx_lo_export_enabled(
        h: uhd_usrp_handle,
        enabled: bool,
        name: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Returns true if the currently selected LO is being exported."]
    pub fn uhd_usrp_get_tx_lo_export_enabled(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        result_out: *mut bool,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the Tx LO frequency."]
    pub fn uhd_usrp_set_tx_lo_freq(
        h: uhd_usrp_handle,
        freq: f64,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        coerced_freq_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the current Tx LO frequency."]
    pub fn uhd_usrp_get_tx_lo_freq(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        tx_lo_freq_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the TX gain for the given channel and name"]
    pub fn uhd_usrp_set_tx_gain(
        h: uhd_usrp_handle,
        gain: f64,
        chan: usize,
        gain_name: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the normalized TX gain [0.0, 1.0] for the given channel\n*!\n* See uhd::usrp::multi_usrp::set_normalized_tx_gain() for more details.\n*/"]
    pub fn uhd_usrp_set_normalized_tx_gain(
        h: uhd_usrp_handle,
        gain: f64,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get all possible gain ranges for the given channel and name"]
    pub fn uhd_usrp_get_tx_gain_range(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        gain_range_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the given channel's RX gain"]
    pub fn uhd_usrp_get_tx_gain(
        h: uhd_usrp_handle,
        chan: usize,
        gain_name: *const ::std::os::raw::c_char,
        gain_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the given channel's normalized TX gain [0.0, 1.0]\n*!\n* See uhd::usrp::multi_usrp::get_normalized_tx_gain() for more details.\n*/"]
    pub fn uhd_usrp_get_normalized_tx_gain(
        h: uhd_usrp_handle,
        chan: usize,
        gain_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of TX gain names for the given channel"]
    pub fn uhd_usrp_get_tx_gain_names(
        h: uhd_usrp_handle,
        chan: usize,
        gain_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the TX antenna for the given channel"]
    pub fn uhd_usrp_set_tx_antenna(
        h: uhd_usrp_handle,
        ant: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the TX antenna for the given channel"]
    pub fn uhd_usrp_get_tx_antenna(
        h: uhd_usrp_handle,
        chan: usize,
        ant_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of tx antennas associated with the given channels"]
    pub fn uhd_usrp_get_tx_antennas(
        h: uhd_usrp_handle,
        chan: usize,
        antennas_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set the bandwidth for the given channel's TX frontend"]
    pub fn uhd_usrp_set_tx_bandwidth(
        h: uhd_usrp_handle,
        bandwidth: f64,
        chan: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the bandwidth for the given channel's TX frontend"]
    pub fn uhd_usrp_get_tx_bandwidth(
        h: uhd_usrp_handle,
        chan: usize,
        bandwidth_out: *mut f64,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get all possible bandwidth ranges for the given channel's TX frontend"]
    pub fn uhd_usrp_get_tx_bandwidth_range(
        h: uhd_usrp_handle,
        chan: usize,
        bandwidth_range_out: uhd_meta_range_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get the value for the given TX sensor"]
    pub fn uhd_usrp_get_tx_sensor(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        sensor_value_out: *mut uhd_sensor_value_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of TX sensors associated with the given channels"]
    pub fn uhd_usrp_get_tx_sensor_names(
        h: uhd_usrp_handle,
        chan: usize,
        sensor_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a list of GPIO banks associated with the given channels"]
    pub fn uhd_usrp_get_gpio_banks(
        h: uhd_usrp_handle,
        mboard: usize,
        gpio_banks_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Set a GPIO attribute for a given GPIO bank\n*!\n* See uhd::usrp::multi_usrp::set_gpio_attr() for more details.\n*/"]
    pub fn uhd_usrp_set_gpio_attr(
        h: uhd_usrp_handle,
        bank: *const ::std::os::raw::c_char,
        attr: *const ::std::os::raw::c_char,
        value: u32,
        mask: u32,
        mboard: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get a GPIO attribute on a particular GPIO bank\n*!\n* See uhd::usrp::multi_usrp::get_gpio_attr() for more details.\n*/"]
    pub fn uhd_usrp_get_gpio_attr(
        h: uhd_usrp_handle,
        bank: *const ::std::os::raw::c_char,
        attr: *const ::std::os::raw::c_char,
        mboard: usize,
        attr_out: *mut u32,
    ) -> uhd_error::Type;
}
#[doc = " Public Datatypes for USRP clock"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_usrp_clock {
    _unused: [u8; 0],
}
#[doc = "! A C-level interface for interacting with an Ettus Research clock device\n*!\n* See uhd::usrp_clock::multi_usrp_clock for more details.\n*\n* NOTE: Attempting to use a handle before passing it into uhd_usrp_clock_make()\n* will result in undefined behavior.\n*/"]
pub type uhd_usrp_clock_handle = *mut uhd_usrp_clock;
extern "C" {
    #[doc = "! Find all connected clock devices.\n*!\n* See uhd::device::find() for more details.\n*/"]
    pub fn uhd_usrp_clock_find(
        args: *const ::std::os::raw::c_char,
        devices_out: *mut uhd_string_vector_t,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Create a clock handle.\n*!\n* \\param h The handle\n* \\param args Device args (e.g. \"addr=192.168.10.3\")\n*/"]
    pub fn uhd_usrp_clock_make(
        h: *mut uhd_usrp_clock_handle,
        args: *const ::std::os::raw::c_char,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Safely destroy the clock object underlying the handle.\n*!\n* Note: After calling this, usage of h may cause segmentation faults.\n* However, multiple calling of uhd_usrp_free() is safe.\n*/"]
    pub fn uhd_usrp_clock_free(h: *mut uhd_usrp_clock_handle) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get last error"]
    pub fn uhd_usrp_clock_last_error(
        h: uhd_usrp_clock_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get board information in a nice output"]
    pub fn uhd_usrp_clock_get_pp_string(
        h: uhd_usrp_clock_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get number of boards"]
    pub fn uhd_usrp_clock_get_num_boards(
        h: uhd_usrp_clock_handle,
        num_boards_out: *mut usize,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get time"]
    pub fn uhd_usrp_clock_get_time(
        h: uhd_usrp_clock_handle,
        board: usize,
        clock_time_out: *mut u32,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get sensor"]
    pub fn uhd_usrp_clock_get_sensor(
        h: uhd_usrp_clock_handle,
        name: *const ::std::os::raw::c_char,
        board: usize,
        sensor_value_out: *mut uhd_sensor_value_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = "! Get sensor names"]
    pub fn uhd_usrp_clock_get_sensor_names(
        h: uhd_usrp_clock_handle,
        board: usize,
        sensor_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error::Type;
}
extern "C" {
    #[doc = " Set the scheduling priority on the current thread.\n\n A new thread or calling process should make this call\n with the defaults this to enable realtime scheduling.\n\n A priority of zero corresponds to normal priority.\n Positive priority values are higher than normal.\n Negative priority values are lower than normal.\n\n \\param priority a value between -1 and 1\n \\param realtime true to use realtime mode\n \\return UHD error code"]
    pub fn uhd_set_thread_priority(priority: f32, realtime: bool) -> uhd_error::Type;
}
